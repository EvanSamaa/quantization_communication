factor = {1:0.25, 2:0.25, 3:0.25, 4:0.25, 5:0.25, 6:0.25, 7:0.25, 8:0.25}
for i in range(0, scheduled_output.shape[1]):
    sr = sum_rate(scheduled_output[:, i], features)
    loss_1 = loss_1 + tf.exp(tf.constant(-scheduled_output.shape[1]+1+i, dtype=tf.float32)) * sr

    # ce = All_softmaxes_CE_general(N_rf, K, M)(raw_output[:, i])
    # loss_4 = loss_4 + tf.exp(tf.constant(-scheduled_output.shape[1]+1+i, dtype=tf.float32)) * ce

    mask = tf.stop_gradient(Harden_scheduling_user_constrained(N_rf, K, M, default_val=0)(scheduled_output[:, i]))
    ce = tf.keras.losses.CategoricalCrossentropy()(scheduled_output[:, i], mask)
    # mse = tf.keras.losses.MeanSquaredError()(scheduled_output[:, i], mask)
    loss_4 = loss_4 + factor[N_rf]*tf.exp(tf.constant(-scheduled_output.shape[1]+1+i, dtype=tf.float32)) * ce


def FDD_per_link_archetecture_more_G(M, K, k=2, N_rf=3, output_all=False):
    inputs = Input(shape=(K, M), dtype=tf.complex64)
    input_mod = tf.square(tf.abs(inputs))
    input_mod = tf.keras.layers.BatchNormalization()(input_mod)
    input_modder = Per_link_Input_modification_more_G_less_X(K, M, N_rf, k)
    dnns = dnn_per_link((M * K,6 + M*K), N_rf)
    # compute interference from k,i
    output_0 = tf.stop_gradient(tf.multiply(tf.zeros((K, M)), input_mod[:, :, :]) + 1.0 * N_rf / M / K)
    input_i = input_modder(output_0, input_mod, k - 1.0)
    raw_out_put_i = dnns(input_i)
    raw_out_put_i = tf.keras.layers.Softmax(axis=1)(raw_out_put_i) # (None, K*M, Nrf)
    # out_put_i = tfa.layers.Sparsemax(axis=1)(out_put_i)
    out_put_i = tf.reduce_sum(raw_out_put_i, axis=2) # (None, K*M)
    output = [tf.expand_dims(out_put_i, axis=1), tf.expand_dims(raw_out_put_i, axis=1)]
    # begin the second - kth iteration
    for times in range(1, k):
        out_put_i = tf.keras.layers.Reshape((K, M))(out_put_i)
        input_i = input_modder(out_put_i, input_mod, k - times - 1.0)
        raw_out_put_i = dnns(input_i)
        raw_out_put_i = tf.keras.layers.Softmax(axis=1)(raw_out_put_i)
        # out_put_i = tfa.layers.Sparsemax(axis=1)(out_put_i)
        out_put_i = tf.reduce_sum(raw_out_put_i, axis=2)
        output[0] = tf.concat([output[0], tf.expand_dims(out_put_i, axis=1)], axis=1)
        output[1] = tf.concat([output[1], tf.expand_dims(raw_out_put_i, axis=1)], axis=1)
    model = Model(inputs, output)
    return model